# Bash 的算术运算

## 算术表达式

`$((...))`语法可以进行整数的算术运算。

```bash
$ echo $((2 + 2))
4
```

上面的例子返回了`2 + 2`的计算结果。

`$((...))`忽略括号内部的空格，所以下面的写法都会得到同样的结果。

```bash
$ echo $((2+2))
4
$ echo $(( 2+2 ))
4
$ echo $(( 2 + 2 ))
4
```

这个语法结构支持的算术运算符如下。

- `+`：加法
- `-`：减法
- `*`：乘法
- `/`：除法（整除）
- `%`：余数
- `**`：指数
- `++`：自增运算（前缀或后缀）
- `--`：自减运算（前缀或后缀）

注意，上面的除法运算符的返回结果总是整数，比如`5`除以`2`，得到的结果是`2`，而不是`2.5`。

```bash
$ echo $((5 / 2))
2
```

`++`和`--`作为前缀是先运算后返回值，作为后缀是先返回值后运算。

```bash
$ i=0
$ echo $i
0
$ echo $((i++))
0
$ echo $i
1
$ echo $((++i))
2
$ echo $i
2
```

上面例子中，`++`作为后缀是返回值，执行`echo`命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行`echo`命令。

`$((...))`结构可以嵌套。

```bash
$ echo $(((5**2) * 3))
75
# 等同于
$ echo $(($((5**2)) * 3))
75
```

`$((...))`内部可以用圆括号改变运算顺序。

```bash
$ echo $(( (2 + 3) * 4 ))
20
```

上面例子中，内部的圆括号可以让加法先于乘法执行。

这个语法只能计算整数，否则会报错。

```bash
# 报错
$ echo $((1.5 + 1))
```

`$((...))`的圆括号之中，不需要在变量名之前加上`$`，不过加上也不报错。

```bash
$ number=2
$ echo $((number + 1))
3
```

`$[...]`也可以做整数运算。

```bash
$ echo $[2+2]
4
```

## 数值的进制

Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。

- `number`：没有任何特殊表示法的数字是十进制数（以10为底）。
- `0number`：八进制数。
- `0xnumber`：十六进制数。
- `base#number`：`base`进制的数。

下面是一些例子。

```bash
$ echo $((0xff))
255
$ echo $((2#11111111))
255
```

上面例子中，`0xff`是十六进制数，`2#11111111`是二进制数。

## 位运算

`$((...))`支持以下的二进制位运算符。

- `<<`：位左移运算，把一个数字的所有位向左移动指定的位。
- `>>`：位右移运算，把一个数字的所有位向右移动指定的位。
- `&：`：位的“与”运算，对两个数字的所有位执行一个`AND`操作。
- `|`：位的“或”运算，对两个数字的所有位执行一个`OR`操作。
- `~`：位的“否”运算，对一个数字的所有位取反。
- `!`：逻辑“否”运算
- `^`：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。
- `,`：求值运算。

下面是左移运算符`<<`的例子。

```bash
#! /bin/bash
for ((i=0;i<4;++i)); do
  echo $((1 << i));
done
```

上面脚本执行后，会依次输出1、2、4、8。

## 逻辑运算

`$((...))`支持以下的逻辑运算符。

- `<`：小于
- `>`：大于
- `<=`：小于或相等
- `>=`：大于或相等
- `==`：相等
- `!=`：不相等
- `&&`：逻辑与
- `||`：逻辑或
- `expr1?expr2:expr3`：三元条件三元运算符。若表达式`expr1`的计算结果为非零值（算术真），则执行表达式`expr2`，否则执行表达式`expr3`。

如果逻辑表达式为真，返回`1`，否则返回`0`。

```bash
$ echo $((3 > 2))
1
$ echo $(( (3 > 2) || (4 <= 1) ))
1
```

三元运算符执行一个单独的逻辑测试。它用起来类似于`if/then/else`语句。

```bash
$ a=0
$ echo $((a<1 ? 1 : 0))
1
$ echo $((a>1 ? 1 : 0))
0
```

上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。

## 赋值运算

算术表达式`$((...))`可以执行赋值运算。

```bash
$ echo $((a=1))
1
$ echo $a
1
```

上面例子中，`a=1`对变量`a`进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。

`$((...))`支持的赋值运算符，有以下这些。

- `parameter = value`：简单赋值。
- `parameter += value`：等价于`parameter = parameter + value`。
- `parameter -= value`：等价于`parameter = parameter – value`。
- `parameter *= value`：等价于`parameter = parameter * value`。
- `parameter /= value`：等价于`parameter = parameter / value`。
- `parameter %= value`：等价于`parameter = parameter % value`。
- `parameter <<= value`：等价于`parameter = parameter << value`。
- `parameter >>= value`：等价于`parameter = parameter >> value`。
- `parameter &= value`：等价于`parameter = parameter & value`。
- `parameter |= value`：等价于`parameter = parameter | value`。
- `parameter ^= value`：等价于`parameter = parameter ^ value`。

如果在表达式内部赋值，可以放在圆括号中，否则会报错。

```bash
$ echo $(( a<1 ? (a+=1) : (a-=1) ))
```

## 算术条件

`$((...))`这个语法之中，真正的算术表达式其实是`((...))`，美元符号只是用来返回`((...))`的值。

在某些场合不需要返回值，这时可以直接使用`((...))`，最常见的就是`if`判断。

```bash
if ((3 > 2)); then
  echo "true"
fi
```

上面代码执行后，会打印出`true`。

注意，算术计算的结果不是`0`，表示条件为真；如果是`0`，表示条件为假。这一点与命令是否执行成功，正好相反。

```bash
$ if ((1)); then echo "It is true."; fi
It is true.
$ if ((0)); then echo "It is true."; else echo "it is false."; fi
It is false.
```

上面代码中，`((1))`表示条件为真，`((0))`表示条件为假。

```bash
$ if (( foo = 5 ));then echo "It is true."; fi
It is true.
```

上面例子中，`(( foo = 5 ))`完成了两件事情。首先把`5`赋值给变量`foo`，然后根据返回值`5`，判断条件为真。

